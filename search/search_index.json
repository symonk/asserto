{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the documentation for <code>Asserto</code>.","text":""},{"location":"#quick-start","title":"Quick Start","text":"<p><code>Asserto</code> can be installed with pip:</p> <pre><code>pip install asserto\n</code></pre> <p>Then import <code>assert_that</code> to get started:</p> <pre><code>from asserto import assert_that\ndef test_something() -&gt; None:\nassert_that(\"Hello\").has_length(5).matches(r\"\\w{5}$\").ends_with(\"lo\").starts_with(\"Hel\")\n</code></pre>"},{"location":"assertions/strings/","title":"Strings","text":""},{"location":"assertions/strings/#string-assertions","title":"String Assertions","text":"<p>Mixin responsible for composing assertions for string types.</p>"},{"location":"assertions/strings/#asserto.mixins._string_mixin.AssertsStringsMixin.ends_with","title":"<code>ends_with(suffix: str) -&gt; Self</code>","text":"<p>Asserts the actual value ends with the particular suffix. When the actual value is a string it is compared using the string builtin.  When the actual value is an iterable, the last element in the iterable is compared for equality against suffix.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>The expected substring for the actual value to end with.</p> required Source code in <code>asserto/mixins/_string_mixin.py</code> <pre><code>def ends_with(self, suffix: str) -&gt; Self:\n\"\"\"Asserts the actual value ends with the particular suffix.\n    When the actual value is a string it is compared using the\n    string builtin.  When the actual value is an iterable, the last\n    element in the iterable is compared for equality against suffix.\n    :param suffix: The expected substring for the actual value to end with.\n    \"\"\"\nif isinstance(self.actual, str):\nif not suffix:\nraise ValueError(f\"{suffix=} must not be empty.\")\nif not isinstance(suffix, str):\nraise TypeError(f\"{suffix=} must be a string.\")\nif not self.actual.endswith(suffix):\nself.error(f\"Expected `{self.actual}` to end with {suffix=} but it did not.\")\nelif isinstance(self.actual, Iterable):\nif not self.actual:\nraise ValueError(f\"{self.actual} must not be empty.\")\nlast: Iterable[Any] = to_iterable(self.actual)[-1]\nif last != suffix:\nself.error(f\"Expected `{self.actual}` to end with {suffix=} but it did not.\")\nelse:\nraise TypeError(f\"{self.actual} is not a string or iterable.\")\nreturn self\n</code></pre>"},{"location":"assertions/strings/#asserto.mixins._string_mixin.AssertsStringsMixin.is_alpha","title":"<code>is_alpha() -&gt; Self</code>","text":"<p>Asserts the actual value is considered alphabetic.  Empty strings will not be considered alphabetic for this case.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The <code>Asserto</code> instance for fluent chaining.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>when the actual value is not of type string.</p> <code>AssertionError</code> <p>when the actual value is not an alphabetic string.</p> Source code in <code>asserto/mixins/_string_mixin.py</code> <pre><code>def is_alpha(self) -&gt; Self:\n\"\"\"Asserts the actual value is considered alphabetic.  Empty strings will\n    not be considered alphabetic for this case.\n    :raises TypeError: when the actual value is not of type string.\n    :raises AssertionError: when the actual value is not an alphabetic string.\n    :return: The `Asserto` instance for fluent chaining.\n    \"\"\"\nif not isinstance(self.actual, str):\nraise TypeError(f\"{self.actual} is not a string, it is of type: {type(self.actual)}.\")\nif not self.actual.isalpha():\nself.error(f\"{self.actual} was not alphabetic.\")\nif isinstance(self.actual, str):\nif not self.actual.isalpha():\nself.error(f\"{self.actual} did not contain only alpha numeric chracters.\")\nelse:\nraise TypeError(f\"{self.actual} is not a string.\")\nreturn self\n</code></pre>"}]}