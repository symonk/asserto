{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the documentation for <code>Asserto</code>.","text":""},{"location":"#quick-start","title":"Quick Start","text":"<p><code>Asserto</code> can be installed with pip:</p> <pre><code>pip install asserto\n</code></pre> <p>Then import <code>assert_that</code> to get started:</p> <pre><code>from asserto import assert_that\ndef test_something() -&gt; None:\nassert_that(\"Hello\").has_length(5).matches(r\"\\w{5}$\").ends_with(\"lo\").starts_with(\"Hel\")\n</code></pre>"},{"location":"assertions/strings/","title":"Strings","text":""},{"location":"assertions/strings/#string-assertions","title":"String Assertions","text":"<p>Mixin responsible for composing assertions for string types.</p>"},{"location":"assertions/strings/#asserto.mixins._string_mixin.AssertsStringsMixin.ends_with","title":"<code>ends_with(suffix: str) -&gt; Self</code>","text":"<p>Asserts the actual value ends with a given prefix.  If the actual value is an iterable, the last element within it will be compared for equality (==) against the suffix.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>The expected substring for the actual value to end with.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The <code>Asserto</code> instance for fluent chaining.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>When the actual value is not a string or iterable.</p> <code>TypeError</code> <p>When the suffix value is not a string.</p> <code>ValueError</code> <p>When the suffix or actual values are empty.</p> <code>ValueError</code> <p>When the actual value is an empty string.</p> <code>AssertionError</code> <p>When the actual value does not end with the suffix.</p> Source code in <code>asserto/mixins/_string_mixin.py</code> <pre><code>def ends_with(self, suffix: str) -&gt; Self:\n\"\"\"Asserts the actual value ends with a given prefix.  If the actual\n    value is an iterable, the last element within it will be compared for\n    equality (==) against the suffix.\n    :param suffix: The expected substring for the actual value to end with.\n    :raises TypeError: When the actual value is not a string or iterable.\n    :raises TypeError: When the suffix value is not a string.\n    :raises ValueError: When the suffix or actual values are empty.\n    :raises ValueError: When the actual value is an empty string.\n    :raises AssertionError: When the actual value does not end with the suffix.\n    :return: The `Asserto` instance for fluent chaining.\n    \"\"\"\nif isinstance(self.actual, str):\nif not suffix:\nraise ValueError(f\"{suffix=} must not be empty.\")\nif not isinstance(suffix, str):\nraise TypeError(f\"{suffix=} must be a string.\")\nif not self.actual.endswith(suffix):\nself.error(f\"Expected `{self.actual}` to end with {suffix=} but it did not.\")\nelif isinstance(self.actual, Iterable):\nif not self.actual:\nraise ValueError(f\"{self.actual} must not be empty.\")\nlast: Iterable[Any] = to_iterable(self.actual)[-1]\nif last != suffix:\nself.error(f\"Expected `{self.actual}` to end with {suffix=} but it did not.\")\nelse:\nraise TypeError(f\"{self.actual} is not a string or iterable.\")\nreturn self\n</code></pre>"},{"location":"assertions/strings/#asserto.mixins._string_mixin.AssertsStringsMixin.is_alpha","title":"<code>is_alpha() -&gt; Self</code>","text":"<p>Asserts the actual value is considered alphabetic.  Empty strings will not be considered alphabetic for this case.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The <code>Asserto</code> instance for fluent chaining.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the actual value is not of type string.</p> <code>AssertionError</code> <p>If the actual value is not an alphabetic string.</p> Source code in <code>asserto/mixins/_string_mixin.py</code> <pre><code>def is_alpha(self) -&gt; Self:\n\"\"\"Asserts the actual value is considered alphabetic.  Empty strings will\n    not be considered alphabetic for this case.\n    :raises TypeError: If the actual value is not of type string.\n    :raises AssertionError: If the actual value is not an alphabetic string.\n    :return: The `Asserto` instance for fluent chaining.\n    \"\"\"\nif not isinstance(self.actual, str):\nraise TypeError(f\"{self.actual} is not a string, it is of type: {type(self.actual)}.\")\nif not self.actual.isalpha():\nself.error(f\"{self.actual} is not alphabetic.\")\nif isinstance(self.actual, str):\nif not self.actual.isalpha():\nself.error(f\"{self.actual} did not contain only alpha numeric chracters.\")\nelse:\nraise TypeError(f\"{self.actual} is not a string.\")\nreturn self\n</code></pre>"},{"location":"assertions/strings/#asserto.mixins._string_mixin.AssertsStringsMixin.is_digit","title":"<code>is_digit() -&gt; Self</code>","text":"<p>Asserts the actual value is a digit string.  Empty strings will not be considered digit strings for this case.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The <code>Asserto</code> instance for fluent chaining.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the actual value is not of type string.</p> <code>AssertionError</code> <p>If the actual value is not an alphabetic string.</p> Source code in <code>asserto/mixins/_string_mixin.py</code> <pre><code>def is_digit(self) -&gt; Self:\n\"\"\"Asserts the actual value is a digit string.  Empty strings will not be considered\n    digit strings for this case.\n    :raises TypeError: If the actual value is not of type string.\n    :raises AssertionError: If the actual value is not an alphabetic string.\n    :return: The `Asserto` instance for fluent chaining.\n    \"\"\"\nif not isinstance(self.actual, str):\nraise TypeError(f\"{self.actual} is not a string, it is of type: {type(self.actual)}.\")\nif not self.actual.isdigit():\nself.error(f\"{self.actual} is not a digit string.\")\nreturn self\n</code></pre>"},{"location":"assertions/strings/#asserto.mixins._string_mixin.AssertsStringsMixin.starts_with","title":"<code>starts_with(prefix: str) -&gt; Self</code>","text":"<p>Asserts the actual value starts with the prefix.  If the actual value is an iterable the first element is compared for equality (==) against the prefix.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The value to check the actual value starts with.</p> required Source code in <code>asserto/mixins/_string_mixin.py</code> <pre><code>def starts_with(self, prefix: str) -&gt; Self:\n\"\"\"Asserts the actual value starts with the prefix.  If the actual value is\n    an iterable the first element is compared for equality (==) against the prefix.\n    :param prefix: The value to check the actual value starts with.\n    \"\"\"\nif isinstance(self.actual, str):\nif not self.actual.startswith(prefix):\nself.error(f\"{self.actual} did not begin with {prefix=}\")\nelse:\nraise TypeError(f\"{self.actual} is not a string or iterable.\")\nreturn self\n</code></pre>"}]}